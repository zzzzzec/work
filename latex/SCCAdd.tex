\documentclass{article}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{xeCJK}
\setCJKmainfont{SimSun}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\makeatletter
\renewcommand{\algorithmiccomment}[1]{\hfill\(\triangleright\) #1}
\makeatother

\begin{document}

\begin{algorithm}
\caption{SCC更新算法-SCC合并}
\begin{algorithmic}[1]
\Require SCC图$G_S$, 更新节点$S_i$
\Ensure 更新后的SCC图$G_{Snew}$, 被合并的节点集合$S$, 合并后新节点的编号$S_{new}$
\Function{SCCMerge}{$G_S$, $S_i$}
    \State $S \gets \emptyset$
    \State $G_{Snew} \gets G_{S}$ 
    \State $S_{old} \gets -1 , S_{new} \gets -1$
    \State $cycle$ = \Call{findCycle}{$ G_{Snew}, S_i$}
    \While {$|cycle| != 0$}
        \State $G_{Snew}, S_{new}$ = \Call{Merge}{$G_{Snew}$, $cycle$}
        \If {$|S| == 0$}
            \State $S = S \cup cycle$
        \Else 
            \State $S = S \cup ( cycle - S_{old} ) $ 
        \EndIf
        \State $S_{old} = S_{new}$
        \State $cycle$ = \Call{findCycle}{$S_{new}, S_{new}$}
    \EndWhile
    \State \Return $G_{Snew}, S, S_new$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{SCC更新算法-寻找环路}
\begin{algorithmic}[1]
\Require SCC图$G_S$, 更新节点$S_i$
\Ensure 返回一个包含环的节点集合$C$
\Function{findCycle}{$G_{S}, S_i$}
    \State $C \gets \emptyset, visited \gets \emptyset$
    \For {each node $v$ in $G_S$}
        \State $visited \cup \{ v:FALSE \}$
    \EndFor
    \State stack $S$
    \State $S$.push($S_i$)
    \While{$!S.empty()$}
        \State $N \gets S$.pop() 
        \For {each outcome edge $e$ of node $N$}
            \If {$e.dst == S_i$}
                \State $C \gets S$
                \State break
            \EndIf
            \If {$!visited[e.dst]$}
                \State $visited[e.dst] = TRUE$ 
                \State $S$.push($e.dst$)
            \EndIf
        \EndFor
    \EndWhile
    \State \Return $C$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{SCC更新算法-合并环路}
\begin{algorithmic}[1]
\Require SCC图$G_S$, 在环中的节点集合$cycle$
\Ensure 返回更新过后的SCC图$G_{Snew}$, 新节点的编号$S_{new}$
    \Function{merge}{$G_{S}, cycle$}
        \State SCCNode $N_{new}$
        \For{each node $N_c$ in $cycle$}
            \State $N_{new}.nodeSet \gets  N_{new}.nodeSet \quad \cup \quad N_c.nodeSet$
        \EndFor
        \State \Comment 需要注意节点ID的重用, SCC节点的主键是原始图节点集合
        \For {each node $S$ in all SCC Graphs $[G_{S0}, G_{S1} ,..., G_{SN}]$}
            \If {$S.nodeSet == N_{new}.nodeSet$}
                \State $N_{new}.nodeID \gets S.nodeID$ 
                \State $reused = TRUE$
            \EndIf
        \EndFor
        \If {$!reused$} \Comment 节点ID未被重用,获取一个新的ID
            \State $N_{new}.nodeID$ = \Call{getNewSCCID}{}
        \EndIf

        \For {each node $N_s$ in $G_S$}
            \If {$N_s$ in $cycle$} \Comment 需要将所有的出边合并到新节点中
                \For {each outcome edge $e$ of $N_s$}
                    \State $N_{new}$.insertOutcomeEdge($e.dst$)
                \EndFor
                $G_{Snew} \gets G_{Snew} - N_s$
            \Else \Comment 需要把出边在$cycle$中的节点改为$N_{new}$
                \For {each outcome edge $e$ of $N_s$}
                    \If {$e.dst$ in $cycle$}
                        \State $N_s$.deleteOutcomeEdge($e.dst$)
                    \EndIf
                \EndFor
                \If {exist edge $e$ where $e.dst$ in $cycle$}
                    \State $N_s$.insertOutcomeEdge($N_{new}.nodeID$)
                \EndIf
            \EndIf
        \EndFor
        \State \Return $G_S , S_{new}.nodeID$ 
    \EndFunction

\end{algorithmic}
\end{algorithm}

\end{document}